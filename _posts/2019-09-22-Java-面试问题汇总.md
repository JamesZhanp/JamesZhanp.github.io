---
layout:     post

title:      Java 面试内容

subtitle:   Java 基础内容面试总结

date:       2019-09-22

author:     JZ

header-img: img/post-bg-swift.jpg

catalog: true

tags:

    - java
    - 面试内容
---

# Java 面试问题汇总

## 相关概念

### 面向对象的三个特征

封装， 继承， 多态

### 多态的好处

允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式，主要优点如下：

可替换性： 多态对于已存在的代码具有可替换性

可扩充性：增加新的子类不影响已经存在的类结构

接口性：多态是超类通过方法签名， 向子类提供一个公共接口，由子类来完善或者重写它来实现

灵活性 简化性

### 如何实现多态

1. 接口实现
2. 继承父类重写方法
3. 同一类中进行方法重载

### 接口的意义

规范、回调、扩展

### 抽象类的意义

抽象类的意义可以概括为三句话：

1.  为子类提供一个公共的类型
2. 封装重复定义的内容
3. 定义抽象方法，子类实现不同， 但定义时一致

### 接口和抽象类的区别

| 比较         | 抽象类                                                       | 接口                                                       |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 默认方法     | 抽象类可以有默认的方法实现                                   | Java 8之前， 接口中不存在方法的实现                        |
| 实现方式     | 子类使用extends关键字继承抽象类。如果子类不是抽象类，子类需要实现父类中所声明的方法 | 子类使用implements来实现接口，需要实现接口中所有声明的实现 |
| 构造器       | 抽象类当中可以有构造器                                       | 接口中不能有构造器                                         |
| 与正常类区别 | 不能实例化                                                   | 完全能不同的类型                                           |
| 访问修饰符   | 抽象方法可以有public, protected和default等修饰               | 默认public，且只能是public                                 |
| 多继承       | 一个子类只能拥有一个父类                                     | 可多继承接口                                               |
| 添加新的方法 | 可以添加新的方法，并且不影响使用子类                         | 子类需要实现新增的方法                                     |

### 子类不能重写父类的静态方法

重写只适用于实例方法，不能用于静态方法，而子类当中含有与父类相同签名的静态方法，称之为隐藏

### 静态变量和实例变量

静态变量存储在方法区， 属于类所有，实例变量存储在堆当中，其引用存在当前线程栈（Java 虚拟机栈）

### Java创建对象的几种方法

1. 采用new
2. 通过反射
3. 采用clone
4. 通过序列化机制

前两者属于显示的调用构造方法。造成耦合性较高的就是第一种

### Switch可以作用在byte上，但是不能作用在long上面

**String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4请问s5==s2返回什么？**

返回false， 因为在编译过程中，s5的结果被修改成了"ab", 同时常量会被放在常量池当中，s5则是被创建在堆区

### equals和==的区别

==：判断两个对象的地址是不是相同，判断两个对象是不是同一个对象（基本数据类型==比较的是值， 引用数据类型 == 比较的是内存地址）

equals：判断两个对象是否相等。两种使用情况：

- 类没有覆盖equals()， 通过equals比较该类的两个对象时， 等教育 == 比较两个对象
- 覆盖equals()方法。判断两个对象的内容是否相等。

object方法比较的是对象的内存地址，因为String方法重写了equals方法比较值

创建String时，虚拟机会在常量池中查找是否有值相同的对象，有，将其赋给当前引用，反之， 重新创建String对象

### String对象的intern()方法

intern()方法会首先从常量池中查找是否存在该变量值， 如果常量池中不存在，则直接在常量池中进行创建，如果存在则直接返回。

### Object方法存在的公用方法

1. `equals()`
2. `toString()`
3. `clone()`
4. `getClass()`
5. `wait(), notify(), notifyAll()`

### ArrayList 和 LinkedList之间的区别

插入： 对于ArrayList， 最后位置插入时间复杂度为O（1）， 其余位置为O（n-i）。ArrayList的底层是一个Obejct的数组，而LinkedList的底层是一个双向链表。 因此对于随机访问而言，ArrayList更为方便。 ArrayList继承了RandomAccess， RandomAccess是一个空接口， 因此可只是随机访问的标识。LinkedList没有继承RandomAccess。

对于ArrayList， 遍历推荐使用 普通for循环，其次foreach

对于LinkedList， 推荐使用iterator遍历（foreach底层使用iterator遍历）

ArrayList默认有一个大小为10的空间大小，ArrayList的是指相当于为数组赋值，比较默认值与用户传入的大小比较，创建较大值得ArrayList

最后调用grow()方法扩容，即大小编程现在容量的1.5倍

### Java 中的引用：

Java中的引用类型分为： 强引用、 软引用、 弱引用、 虚引用

- **强引用**

只要引用存在，则垃圾回收器永远不会回收

```
Object obj = new Object();// obj是强引用。 通过关键字new创建的对象所关联的对象是强引用
```

​       特点：JVM内存空间不足时，JVM宁愿抛出OOM运行错误，是程序异常终止，也不会靠回收具有引用的”存活“对象来解决内存不足的问题。对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者将强引用赋值为null；则可以根据具体的垃圾回收机制被回收

-  **软引用**

非必需引用， 生命周期比强引用短一些，内存溢出之前进行回收

```java
/**
内存溢出后回收
*/
ReferenceQueue queue = new ReferenceQueue();
User user = new User();
SoftReference reference = new SoftReference(user, queue);
user = null
```

其中reference是对user的一个软引用，ref.get()可以取得这个对象，此处软引用和一个引用队列，联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机会把这个软引用加入到与之相关联的引用队列中。后续使用ReferenceQueue的poll方法来检测其所关系的对象是否被回收。如果队列为空，则返回一个null， 否则该方法返回队列中前面的那个Reference对象

应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

- **弱引用**

 弱引用通过`**WeakReference**`类实现，弱引用的生命周期比软引用短，被弱引用关联对象只能生存到*下一次垃圾回收之前*，。在垃圾回收器线程扫描它所管辖的内存区的过程中，一旦发现具有弱引用的对象，不管当前的内存空间足够与否，都会回收的内存。（由于垃圾回收器线程是一个优先级很低的线程，因此不一定会很快回收引用的对象）。

```java
/*
* 只可以生存到下一次垃圾回收之前
*/
ReferenceQueue queue = new ReferenceQueue();
User user = new User();
WeakReference<User> reference = new WeakReference<User>(userqueue);
```

 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

应用场景：弱引用同样是很多缓存实现的选择。

- **虚引用**

 通过PhantomReference类来实现。无法通过幻象引用访问对象的任何属性或函数。幻象引用仅仅是提供一种确保对象被finalize以后，做某些事情的机制。如果一个对象仅持有幻象引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

```java
/*
* 虚引用无法访问对象的任何属性与函数
*/
@SuppressWarnings("rawtypes")
ReferenceQueue queue = new ReferenceQueue();
PhantomReference<User> reference = new PhantomReference<Use(new User(), queue);
System.out.println(reference.get());
```

 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存前，将这个虚引用加入到关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入引用队列，就可以在多引用的对象回收前采取一些程序行动。

应用场景：可以用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾回收器回收之前会收到一条系统通知。

### 为什么要有不同的引用类型

不同于C语言可以控制内存的申请和释放， 在Java中需要适当的控制对象被回收的时机， 因此诞生了不同的引用类型，可以说不同的引用类型实则是对GC回收实际不可控的妥协。

1. 利用软引用和弱引用解决**OOM问题**：用一个HashMap来保存图片的路径和相应图片对象关联表的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片所占用的空间，从而有效的避免OOM的问题
2. 通过软引用实现**Java对象的高速缓存**:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。

### == 与equals的区别， equals()he hashcode的差别

==是运算符，用于比较两个变量是否相等，而equals是object的方法，用于比较两个对象是否相等。默认Object类的equals方法是比较两个对象的内存地址，此时结果和==一样，如果需要比较对象内容，则需要重写equals

### equals和hashcode之间的联系

hashcode()是Object类的一个方法，返回一个哈希值， 如果两个对象根据equals()方法比较相等，那么调用hashcode方法的返回值也一定相等。

**PS：存在某种情况下， 两个不相同的对象有相同的hashcode**

### **深拷贝和浅拷贝的区别是什么**

浅拷贝：被复制对象的所有变脸比都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之。浅拷贝仅仅复制所考虑的对象，不复制所引用的对象。

深拷贝： 被复制对象昂的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象， 而不再是原有的那些被引用的对象。换言之，深拷贝把要赋值的对象所引用的对象都复制了一遍   

### String, StringBuffer和StringBuilder的区别

String是字符串常量， final修饰， StringBuffer是字符串变量（线程安全）， StringBuilder也是字符串变量，线程不安全。

String是不可变对象，每次对String操作等同于产生一个新的String对象， 然后指向新的String对象。因此尽量减少对于String进行拼接操作， 否则会产生大量的临时对象， 导致GC开始工作，影响系统性能

现在的JVM对于String拼接会做出优化，`Sting s = "This is " +“a demo”` 会直接被优化成` String s = "This is a demo"`

### 可以将int强制转换成byte类型吗？会产生什么问题？

可以强制转换，但是int是32位， byte是8位的，强制转换的话，会丢弃高24位

## 垃圾回收

垃圾回收主要发生在虚拟机的**堆、栈**部分， 少部分发生在**方法区**

### 垃圾回收哪些对象：

引用计数法判断对象是否使用，问题：当对象之间相互偶和使用，则永远不会被回收

可达性分析法：通过一些列称为GC Roots的对象作为起始点， 当一个对象到GC Root时没有任何引用链相连，证明次对象是可回收的。 可做GC Roots的对象有： 虚拟机栈中引用的对象（本地变量表）， 方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象

### 垃圾回收的算法

1. 标记-清除：垃圾回收分为连个阶段，标记和清除，
2. 标记-赋值
3. 标记-整理
4. 分代回收

### 如何判断一个对象是否应该被回收

对象存活性判断**引用计数法， 对象可达性法**

### 解释一下垃圾回收

Java垃圾回收机制最基本的方法是分代回收。内存中的区域被分为不同的世代， 对象根据其存活的时间被保存在对应世代的区域中。一般分为：**年轻，年老**和**永久。**内存的分配时发生在年轻世代中的，当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代采取不容的垃圾回收算法。进行世代划分的主要出发点是对应用中对象存活时间进行研究之后得出的统计规律。

### 调用System.gc()会开始GC工作，真正开始的时间不确定

## 线程

### Thread类中的start()和run()方法有什么区别？

start()方法用来启动新创建的线程，start()方法内部调用了run()方法，调用run()方法的时候，在原来的线程中调用，没有启动新的线程，因此新的线程启动使用start()

### Runnable和Callable的区别

Runnable接口中的run()方法的返回值是void， 它做的事情只是存粹的执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型， 和Future，FutureTask配合可以用来获取一场执行的结果。

wait和sleep之间的区别：

wait是object中的方法，sleep是Thread中的方法

wait会释放锁，而sleep不会

wait释放CPU资源， sleep不会

wait需要与notify等使用，sleep不需要， 只需指定睡眠时间

### 为什么wait, nofity和nofityAll这些方法不放在Thread类当中

一个很明显的原因是JAVA提供的锁是**对象级**的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

### synchronized和ReentrantLock的区别

1. synchronized是关键字，而ReentrantLock是类
2. ReentrantLock可以获取锁独享的等待时间，避免死锁`boolean lockFlag  = flag.tryLock(time);`
3. ReentrantLock可以获取各种锁的信息
4. ReentrantLock可以灵活实现多路通知
5. 两者锁的机制也不同，ReentrantLock调用的是底层Unsafe的park方法枷锁，而synchronized是对象头中的mark word

### ReentrantLock独有：

1. ReentrantLock可以指定是否为公平锁，synchronized只能是抢占式的非公平锁

```
ReentantLock lock = new ReentrantLock(true)
```

​    2.  ReentrantLock中的Conditon类可以唤醒制定的线程，synchronized要么随机唤醒一个，要么全部唤醒

```
Condition customer = lock.newCondition();
```

​    3.ReentrantLock 提供了一种能够中断等待锁的线程机制。

```
lock.lockInterruptibly()
```

### FutureTask

FutureTask表示一个异步运行的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对异步运算的结果进行等待获取，判断是否完成， 取消任务等。

### Java当中有哪些锁

1. **自旋锁**:在JDK1.6之后默认开启。共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起或者恢复线程过于浪费，因此在这边做了一个简单的处理，让后面的请求锁的线程稍微等待一会，但不放弃处理的执行时间，看持有锁的线程能否快速释放锁，为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。1.6之后，引入了自适应的自旋锁，也就是等待的时间不再固定， 而是由上一次在同一个锁上的自旋时间和锁的拥有者的状态。
2. **偏向锁**：消除数据在无竞争情况下的同步原。进一步提升程序的运行性能。偏向锁：偏向第一个获得该锁的线程， 如果接下来的过程,该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步，偏向锁可以提高带有同步但无竞争的程序性能，
3. **轻量级锁**：为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。

### 线程键共享数据

通过线程之间共享对象，然后通过 wait， notify， notifyall或者 await， signal， signalall进行唤醒和等待

### 线程局部变量ThreadLocal

线程局部变量是局限于线程内部的变量， 属于线程私有。 java提供ThreadLocal来支持线程局部变量，是一种实现线程安全的方法。 但在管理环境下需小心，完成工作后释放，避免内存泄漏。

### 生产者消费者

作用： 通过平衡生产者和消费者来提升系统的运行效率， 解耦，生产者和消费者之间的联系较少

实现方式： wait/notifyall, ReentrantLock(condition), BlockingQueue

## 线程池

### 使用线程池的原因：

避免频繁的创建和销毁线程，达到线程对象重用的目的，线程池可灵活的控制并发数量

java中使用的线程调度算法为抢占式，当一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等计算出下一个的优先级

### Thread.sleep(0)的作用是

因为java线程之间是抢占式的，存在某个线程一直占用cpu的情况，为了让某些优先级较低的线程获得CPU的控制权，使用Thread.sleep(0)手动触发时间片的分配操作

### CAS是什么‌

CAS（Compare And Swap），CAS操作需要三个操作数：内存地址V， 旧的预期值A，即将要更新的目标值B

CAS执行指令时， 当且仅当内存地址V的值，与预期值V相等时，将地址V的值修改为B，否则什么都不做。整个比较并替换的操作是一个原子操作

缺点：

1. 循环时间长开销大
2. 只能保证一个共享变量的原子操作
3. ABA问题（内存地址初始值为A， 准备赋值时任然为A， 未改变？？？ 可能期间值曾经被修改成了B，后来又被修改成了A，那CAS操作就会误认为他从来没有被改变过）

## IO

IO分类：

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### BIO,NIO,AIO 有什么区别?

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入**必须阻塞在一个线程内**等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (New I/O):** NIO是一种**同步非阻塞的I/O**模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel`两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

BIO，Socket + 多线程（同时处理多个客户端请求，必须使用多线程， 原因socket.accept() socket.read()  socket.accept()，设计的三个函数都是同步阻塞的）， 在接受到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理， 处理完成之后， 通过输出流返回应答给客户端， 线程销毁。（使用线程池减少线程的创建销毁等）

异步I/O通信架构： 线程池和任务队列， 将客户端的socket封装成一个个的Task，后进入线程池进行处理

NIO（New IO）

特性与IO的区别

1). **No-Blocking IO**

IO流是线程阻塞的，NIO流是线程非阻塞的，　NIO在从通道读取或者写入时，　线程可以处理其余的事情，而IO的读写操作流是线程阻塞的

2). **Buffer（缓冲区）**

IO操作面向流，而NIO面向缓冲区，在NIO当中所有的数据都是在缓冲区处理的，常用的有ByteBuffer，提供一组用于操作byte数组，除了boolean之外，所有的Java基本类型都有一个缓冲区。

3). **Channel 通道**

NIO通过Channel（通道）进行读写。   通道时双向的，可读也可写，而流的读写是单向的。无论读写，通道只能与缓冲区进行交互。

4). **Selector 选择器**

选择器用于使用单个线程处理多个通道。 因此需要较少的线程处理通道。

5).**NIO读写数据方式**

NIO的所有IO都是从channel开始的

- 从通道进行数据读取：创建一个缓冲区，然后请求通道读取数据
- 从通道进行写入： 创建一个缓冲区，填充数据，并要求通道写入数据。





 