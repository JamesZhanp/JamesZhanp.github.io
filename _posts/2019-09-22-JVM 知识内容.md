\---

layout:     post

title:      JVM基础内容

subtitle:   Java 虚拟机内容

date:       2019-09-22

author:     JZ

header-img: img/post-bg-swift.jpg

catalog: true

tags:

​    \- java

​    \- JVM

\---



# JVM 知识内容

## JVM 内存结构

java虚拟机内存的5个部分：

- 程序计数器
- Java虚拟机栈
- 本地方法栈
- 堆
- 方法区

![img](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LhJiyDNbX84FynNFWuE%2F-LigLQ-N3Q9h28nig5U2%2F-LigbAm9zCrHUgVpdMls%2Fimage.png?alt=media&token=f12d22dd-3f23-4558-8346-e6459b52a465)

JVM内存结构

JDK 1.8 相较于 1.7 **最大的差别就是：**元数据区取代永久代，元空间的本质与永久代类似，都是对JVM规范中的方法区的实现。区别： 元数据空间不存在虚拟机中， 而是使用本地的内存。

## 程序计数器（PC寄存器）

### 程序计数器的定义

程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为 `Undefined`

### 程序计数器的作用

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来之后，可知上次线程执行的位置

### 程序计数器的特点

- 是一块较小的内存空间
- 线程私有，每条线程有自己的程序计数器
- 生命周期： 随着线程的创建而创建，随着线程的结束而销毁
- 是唯一一个不会出现 `OutOfMemoryError的内存区域`

## Java虚拟机栈（Java栈）

### Java虚拟机栈的定义

Java虚拟机栈是描述Java方法运行过程的内存模型

Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域。 用于存放该方法运行过程中的某些信息：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息
- ……

![img](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LhJiyDNbX84FynNFWuE%2F-LigLQ-N3Q9h28nig5U2%2F-LigbPvBYt64u_U4W2_v%2Fimage.png?alt=media&token=18b1ce6f-9739-42de-8b51-7a5424adb461)

JVM栈

### 压栈出栈过程

当方法运行过程中需要创建局部变量时， 就将局部变量的值存入栈帧中的局部变脸表中

Java虚拟机栈的栈顶的栈帧是当前**正在执行的活动栈**，也就是当前正在执行的方法，**PC寄存器**也会指向这个地址。只有这个活动的栈帧的**本地变量**可以被操作数栈使用，当这个栈帧中调用另一个方法，与之对应别的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。

方法结束后，大概千栈帧被移除， 栈帧的返回值编程新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化

> 由于Java虚拟机栈是与线程相对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不存在同步锁的问题

### Java虚拟机栈的特点

- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
- Java虚拟机栈会出现的两种异常： `StackOverFlowError` 和 `OutOfMemoryError`
  - `StackOverFlowError`若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机的最大深度时，会抛出上述异常。
  - `OutOfMemoryError` 若允许动态扩展，那么当线程请求栈时内存用完， 无法再扩展时， 抛出内存溢出异常
- Java 虚拟机栈也是县城私有，与线程相同的生命周期

##  本地方法栈（C栈）

### 本地方法栈的定义

本地方法栈是为JVM运行**Native（Java源码当中一些使用C语言实现的方法）**方法准备的空间， 因为Native方法是用C语言实现的，因此被叫做C栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行时的内存模型。

### 栈帧变化过程

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。

## 堆

### 堆的定义：

用来存放对象的内存空间，几乎所有的**对象**都存储在堆中

### 堆的特点

- 线程共享，整个虚拟机中只有一个堆， 所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是线程私有的
- 在虚拟机启动时创建
- 是垃圾回收的主要场所
- 进一步可分为：新生代金额老年代

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

堆的大小即可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满的情况， 且内存无法扩展时，就抛出OutOfMemoryError异常

> Java 堆使用的内存不需要保证是连续的。 而由于堆是被所有线程共享的，所以对于他的访问需要注意同步问题，方法和对应属性都需要保证一致性

## 方法区

### 方法区的定义

Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：

- 已经被虚拟机**加载的类信息**
- **常量**
- **静态**变量
- 即时编译器**编译**后的**代码**

### 方法区的特点

- **线程共享**。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
- **永久代**。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
- **内存回收效率低**。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。
- Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

### 运行时常量池

方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码， 常量就存放在运行时常量池中。

当类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。在运行期间，可以向常量池中添加新的常量。

## 直接内存（堆外内存）

直接内存是除Java虚拟机之外的内存，也能被Java使用

### 操作直接内存

在NIO中引入一种基于通道和缓冲的IO方式，可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过在一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，提高数据操作的效率。

直接内存的大小不受Java虚拟机控制，还是会有`OutOfMemory`异常

 

### 直接内存与堆内存比较

- 直接内存申请空间耗费更高的性能
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。