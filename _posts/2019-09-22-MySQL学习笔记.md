---
layout:     post

title:      MySQL 内容

subtitle:   MySQL 学习笔记

date:       2019-09-22

author:     JZ

header-img: img/post-bg-swift.jpg

catalog: true

tags:

    - MySQL
---

# MySQL学习笔记

## 概述

MySQL查询过程

![img](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LhJiyDNbX84FynNFWuE%2F-LjtEC2oVBsoZqwNpv-t%2F-LjtEQ7AcEvbvnXNE3C5%2Fimage.png?alt=media&token=32c80475-558f-4060-933b-bdd4fe1c8905)

MySQL查询过程

## 数据库优化

## **优化的范围有哪些**

**存储、主机和操作系统方面：**

- 主机架构稳定性；
- I/O规划及配置；
- Swap交换分区；
- OS内核参数和网络问题。

**应用程序方面：**

- 应用程序稳定性；
- **SQL语句性能**；
- 串行访问资源；
- 性能欠佳会话管理；
- 这个应用适不适合用MySQL。

**数据库优化方面：**

- 内存；
- 数据库结构（物理&逻辑）；
- 实例配置；

## 优化维度

硬件、系统配置、数据库表结构、SQL及索引

优化成本： 硬件  > 系统配置 > 数据库表结构 > SQL及索引

优化效果： 硬件  < 系统配置 < 数据库表结构 < SQL及索引

## 优化常见的方法

不建议使用数据库内部的枚举类型和集合类型

对于金额：建议使用decimal，不损失精度，尽量避免出现小数，降单位（元-》分）

尽可能的选择小的数据类型和指定长度

尽可能使用not  null：非空字段的处理要比空字段的处理更加的高效，且不需要判断是否为空，对于空的判断不能使用<> ==等， 使用is  null 或者is  not null

单表字段不宜过多，20-30为上限

## 三大范式

- 1NF：字段原子性： 字段不可分割（关系型数据库默认满足）
- 2NF： 消除对主键的部分依赖（新增独立字段作为主键）
- 3NF： 消除对主键的传递依赖（）

## 存储引擎

默认为**Innodb**

MyISAM：以读写为插入为主的应用程序，博客、新闻门户网站

Innodb：更新操作频率较高，或者要保证数据的完整性， 并发量高，支持事务和外间保证数据完整性。 InnoDB采用MVCC来支持高并发，实现四个标准隔离级别（未提交读、提交读、可重复读、可串行化）， 默认级别为可重复读，在此前提下可使用MVCC + Next-Key Locking防止幻读。

InnoDB的主索引为**聚簇索引**，在索引中保存了数据，避免直接读取磁盘，因此主键查询有较高的性能。

InnoDB的优化：从磁盘读取数据时采用的可预测性读，能够自动在内存中船舰hash索引加速读操作

- 聚簇索引：**聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据**

#### 两者的区别

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持**表级锁**，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持**外键**。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

## 索引

关键字与数据的隐射关系成为索引。关键字是从数据当中提取用于标识， 检索数据的 特定内容

索引检索快的原因：

MySQL的基本存储结构是页（存在磁盘当中）

![img](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LhJiyDNbX84FynNFWuE%2F-Lk1zzPhd9u8glVmlGHr%2F-Lk2gUa8T-hg5yoDKKP7%2Fimage.png?alt=media&token=e626af2a-279d-4512-88bd-d434c353da09)

MySQL存储结构

- **各个数据页**之间可以组成一**双向**链表

- **每个**数据页中的记录又可以组成一个**单向**链表

  - 数据页会为存储在其中的记录生成一个**目录页**， 在通过主键查找某条记录的时候可以在页面中使用**二分法**快速的定位到对应的**槽位**，然后遍历该槽位对应分组中的记录可以快速找到指定的记录
  - 以其他非主键列为标准机型搜索： 从最小记录开始遍历单链表中的每条记录

  默认搜索执行：

  - 定位到记录所在的页：遍历双向链表，找到页
  - 从所在的页内查找相应的记录：不是根据主键查询，遍历单链表

  索引为何能加快查询速度：将无序的数据变成相对有序

![img](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LhJiyDNbX84FynNFWuE%2F-Lk1zzPhd9u8glVmlGHr%2F-Lk2j2w42blxVmhmX6-T%2Fimage.png?alt=media&token=bbd918c3-a9cd-4407-873a-736d6609634c)



原因：

- 关键字相对于数据本身， **数据量小**
- 关键字是**有序**的， 二分查找可快速确定位置

MySQL的索引使用的数据结构主要有BTree索引和哈希索引。 哈希索引的底层结构为哈希表，当为单条数据查询的时候可以使用哈希索引，其余使用BTree

MySQL的BTree索引使用的主要数据结构为B+Tree, 但是不同的存储引擎的实现方式不同：

- MyISAM： B+Tree叶节点的data域存放的是数据记录的地址。 在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出data域的值， 然后以data域的值为地址读取相应的数据记录， 这被称为“非聚簇索引”
- InnoDB：其数据文件本身就是索引文件， 相比MyISAM， 索引文件和数据文件是分离的， 其表数据文件本身就是按B+Tree组织的一个索引，树的叶节点data域保存了完整的数据记录。 这个索引的key是数据表的主键，因此Innodb表数据文件本身就是主索引， 这被称为“聚簇索引”而其余的索引都作为辅助索引， 辅助索引的data域存储应记录主键的值而不是地址，这是和MyISAM的不同之处，在根据主键索引时， 直接找到key所在的节点即可直接取出数据，在根据辅助索引查找时，会先去除主键的值，遍历一遍主索引。

## 事务相关

### ACID

- 原子性：事务不可分割，执行的最小单位
- 一致性：执行前后数据保持一致， 多个事务对于同一个数据的读取结果相同
- 隔离性： 并发访问数据库时，一个用户的事务不被其余用户的事务所干扰
- 持久性： 事务被提交之后，对于数据库中的数据改变是持久的

### 并发事务带来的问题：

- **脏读**: 一个事务对于数据进行修改，还未提交，此时新的事物读取了该数据，使用了未被提交的数据
- **丢失修改**：两个事务对于数据进行修改，A修改之后，B也进行了修改，A修改的数据丢失
- **不可重复读**：在一个事务内多次读取某个数据。在一个事务还未结束时，另一个事务对于该数据进行了修改，导致两次读取的数据可能不完全相同（修改）
- **幻读**：与不可重复读类似，事务T1 读取几行数据， 此时T2插入了某些数据，在随后的查询中，第一个事务和获得很多原本不存在的记录。（新增或删除）

### 事务的隔离级别， MySQL的默认隔离级别

- READ-UNCOMMITED（读取未提交）：最低的隔离级别，允许读取尚未提交的数据，可能会造成脏读、不可重复读，幻读
- READ-COMMITED （读取以提交）：允许读取并发事务已经提交的数据， 可以阻止脏读，但还是会引起不可重复读和幻读
- REPEATABLE_READ（可重复读）：对统一字段的多次读取结果都是一致的，除非数据是被自身失误所修改的， 可以阻止脏读和不可重复读， 但是不能解决幻读问题
- SERIALIZABLE（可串行化）：最高的隔离级别，完全符合ACID， 所有事物依次执行，避免上述问题

MySQL的Innodb的默认个理解别是**REPETALABLE-READ，** 可以通过`SELECT @@tx_isolation`

需注意的是： 与SQL标准不同的地方，因为Innodb的REPETABLE-READ事务隔离级别下使用的是Next-Key Lock锁算法，可避免幻读。 Innodb存储引擎的默认支持的隔离级别已经乐意去安全保证事务的隔离性要求，即到达了SERIALIZABLE隔离级别

## 锁机制和InnoDB存储引擎使用的锁

MyISAM使用的是表级锁， InnoDB使用的是行级锁

### 行 级锁和表级锁的对比

表级锁：MySQL中粒度最大的一种锁，对整张表加锁，资源消耗少，枷锁快，不会出现死锁的情况。锁冲突的概率最高，并发率低。

行级锁：粒度最小的锁，只针对当前操作的行进行枷锁，减少数据库操作的冲突，加锁粒度小，并发度高，开销大，加锁慢，会出现死锁。

 

**相关知识点：**

1. innodb对于行的查询使用next-key lock
2. Next-locking keying为了解决Phantom Problem幻读问题
3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

## 大表优化

1. 限定数据的范围：禁止不带任何限制数据范围条件的查询语句

2. 读写分离：数据库拆分，主库写， 从库读

3. 垂直分区：

   根据数据库中数据表相关性进行拆分，将一张数据表拆分成多张数据表

   1. 优点： 使得列数据表笑，查询时较少Block数， 减少I/O次数。简化表，易于维护
   2. 缺点：主键冗余， 需要管理冗余列，引起join操作，可以通过应用层进行join解决，垂直分区会让事务变得复杂

4. 水平分区

   1. 保持数据表结构不变， 通过某种策略存储数据分片。将每一片数据分散到不同的表或者库中，达到分布式的目的。（单表数据量大于2million）
   2. 只为了解决单一表数据过大的问题，但由于表的数据还是在同一机器上的，没有提升并发的能力

 